"use strict"

// Dictionary from prime powers, q=p^n, to the tuple (p,n)
let prime_powers = {
    2:  [ 2, 1],
    3:  [ 3, 1],
    4:  [ 2, 2],
    5:  [ 5, 1],
    7:  [ 7, 1],
    8:  [ 2, 3],
    9:  [ 3, 2],
    11: [11, 1],
    13: [13, 1],
    16: [ 2, 4],
    17: [17, 1],
    19: [19, 1]
}

// Dictionary from q=p^n to a list of coefficients for an irreducible degree-n monic
// polynomial over Z_p, where coefficients are listed from lowest to highest order terms.
// This was generated using the script find_irreducible_polynomials.py
let q_to_poly = {
    2: [0, 1],
    3: [0, 1],
    4: [1, 1, 1],
    5: [0, 1],
    7: [0, 1],
    8: [1, 1, 0, 1],
    9: [1, 0, 1],
   11: [0, 1],
   13: [0, 1],
   16: [1, 1, 0, 0, 1],
   17: [0, 1],
   19: [0, 1],
}

function mod(x, m) {
    // Returns the unique integer between 0 and |m|-1 which is equal to x in Z_m
    // Assumes that x and m are integers and m is nonzero
    return (x % m + Math.abs(m)) % m;
}

class Polynomial {
    // Stores a polynomial as an array of coefficiencts, where coeffs[i] is the coefficient of x^i
    // Assumes the polynomial is over the field Z_p, where the modulus p is prime
    constructor(modulus, coeffs) {
        this.modulus = modulus;
        this.coeffs = coeffs.map(x => mod(x, modulus));
        this.strip_leading_zeros();
    }
    strip_leading_zeros() {
        while (this.coeffs[this.coeffs.length - 1] == 0) {
            this.coeffs.pop();
        }
    }
    deg() {
        // Returns degree of the polynomial
        this.strip_leading_zeros();
        return this.coeffs.length - 1;
    }
    neg() {
        // Returns additive inverse
        return new Polynomial(this.modulus, this.coeffs.map(x => -x));
    }
    add(f) {
        // Returns this plus f, where f is another Polynomial
        console.assert(f.modulus == this.modulus);
        var sum_coeffs = [];
        for (var i = 0; i <= Math.min(this.deg(), f.deg()); i++) {
            sum_coeffs.push(this.coeffs[i] + f.coeffs[i]);
        }
        sum_coeffs.push(... this.coeffs.slice(Math.min(this.deg(), f.deg()) + 1));
        sum_coeffs.push(...    f.coeffs.slice(Math.min(this.deg(), f.deg()) + 1));
        return new Polynomial(this.modulus, sum_coeffs);
    }
    sub(f) {
        // Returns this minus f, where f is another Polynomial
        return this.add(f.neg());
    }
    mul(f) {
        // Returns this times f, where f is another Polynomial
        console.assert(f.modulus == this.modulus);
        var prod_coeffs = [];
        for (var i = 0; i <= this.deg() + f.deg(); i++) {
            prod_coeffs.push(0);
            for (var j = 0; j <= i; j++) {
                if (j > this.deg() || i-j > f.deg()) {
                    continue;
                }
                prod_coeffs[i] += this.coeffs[j] * f.coeffs[i - j];
            }
        }
        return new Polynomial(this.modulus, prod_coeffs);
    }
    quotient(f) {
        // Returns quotient by of this by the ideal generated by the monic Polynomial f,
        // expressed as a representative element whose degree is lower than the degree of f
        console.assert(f.coeffs[f.coeffs.length - 1] == 1);
        console.assert(f.modulus == this.modulus);
        return this.sub(f.mul(new Polynomial(this.modulus, this.coeffs.slice(f.deg()))));
    }
}

class FiniteField {
    /* Defines addition and multiplication of elements in the finite field of order q=p^n,
    where p is a prime number and n is a positive integer. The field is represented as

    F_{p^n} := F_{p}[x]/<f(x)>,

    where f(x) is a degree n (monic) irreducible polynomial over F_p.
    Let r be any root of f, so f(r)=0. Then any element of the field F_{p^n} can be
    uniquely represented by the polynomial

    a_0 + a_1 r + a_2 r^2 + ... + a_{n-1} r^{n-1},

    which makes addition and multiplication behave the way they should. That same
    element can also be represented as a single integer in [0, p^n - 1]:

    a_0 + a_1 p + a_2 p^2 + ... + a_{n-1} p^{n-1}.

    That integer representation does not make addition and multiplication work the way
    they should, but it is more convenient and human-readable. */
    constructor(q) {
        this.q = q
        this.p = prime_powers[q][0];
        this.n = prime_powers[q][1];

        this.cache = {};

        this.modulus = new Polynomial(this.p, q_to_poly[q]);
    }
    int_to_poly(num) {
        // Convert an integer to a polynomial with coefficients in F_p
        var poly_coeffs = [];
        for (var i = 0; i < this.n; i++) {
            poly_coeffs.push(num % this.p);
            num = Math.floor(num / this.p);
        }
        return new Polynomial(this.p, poly_coeffs);
    }
    poly_to_int(poly) {
        // Convert a polynomial to an integer using base p encoding
        var integer_form = 0;
        for (var i = 0; i < poly.coeffs.length; i++) {
            integer_form += poly.coeffs[i] * (this.p ** i);
        }
        return integer_form;
    }
    add(a, b) {
        // Add two field elements (given as integers)
        if (a+'+'+b in this.cache) {
            return this.cache[a+'+'+b];
        }
        let poly_a = this.int_to_poly(a);
        let poly_b = this.int_to_poly(b);
        let poly_sum = poly_a.add(poly_b).quotient(this.modulus);
        let a_plus_b = this.poly_to_int(poly_sum);
        this.cache[a+'+'+b] = a_plus_b
        this.cache[b+'+'+a] = a_plus_b
        return a_plus_b
    }
    mul(a, b) {
        // Multiply two field elements (given as integers)
        if (a+'*'+b in this.cache) {
            return this.cache[a+'*'+b];
        }
        let poly_a = this.int_to_poly(a);
        let poly_b = this.int_to_poly(b);
        let product = poly_a.mul(poly_b).quotient(this.modulus);
        let a_times_b = this.poly_to_int(product);
        this.cache[a+'*'+b] = a_times_b;
        this.cache[b+'*'+a] = a_times_b;
        return a_times_b;
    }
    inv(a) {
        // Returns multiplicative inverse of a
        if ("1/"+a in this.cache) {
            return this.cache["1/"+a];
        }
        for (var i = 0; i < this.q; i++) {
            if (this.mult(a, i) == 1) {
                this.cache["1/"+a] = i;
                this.cache["1/"+i] = a;
                return i;
            }
        }
    }
    neg(a) {
        // Returns additive inverse of a
        if ('-'+a in this.cache) {
            return this.cache['-'+a];
        }
        for (var i = 0; i < this.q; i++) {
            if (this.add(a, i) == 0) {
                this.cached_neg['-'+a] = i;
                this.cached_neg['-'+i] = a;
                return i;
            }
        }
    }
    div(a, b) {
        return this.mult(a, this.inv(b));
    }
}

class IncidenceStructure {
    // Pretty much the same as a hypergraph, except the hyperedges are called lines
    // Vertices are labeled as integers from 0 to V-1, and lines are sets of vertices
    constructor(V, lines = []) {
        this.V = V;
        this.lines = lines;
    }
    dual() {
        // Returns a new incidence structure, equal to the dual of this one
        var dual_structure = new IncidenceStructure(
            this.lines.length,
            Array.from({length: this.V}, () => new Set())
        );
        // TODO: finish making this function
        return dual_structure;
    }
}

class ProjectivePlane extends IncidenceStructure {
}

class AffinePlane extends IncidenceStructure {
}
