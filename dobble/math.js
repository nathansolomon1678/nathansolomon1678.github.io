"use strict"

// Dictionary from prime powers, q=p^n, to the tuple (p,n)
let prime_powers = {
    2:  [ 2, 1],
    3:  [ 3, 1],
    4:  [ 2, 2],
    5:  [ 5, 1],
    7:  [ 7, 1],
    8:  [ 2, 3],
    9:  [ 3, 2],
    11: [11, 1],
    13: [13, 1],
    16: [ 2, 4],
    17: [17, 1],
    19: [19, 1]
}

// Dictionary from q=p^n to a list of coefficients for an irreducible degree-n monic
// polynomial over Z_p, where coefficients are listed from lowest to highest order terms.
// This was generated using the script find_irreducible_polynomials.py
let q_to_poly = {
    2: [0, 1],
    3: [0, 1],
    4: [1, 1, 1],
    5: [0, 1],
    7: [0, 1],
    8: [1, 1, 0, 1],
    9: [1, 0, 1],
   11: [0, 1],
   13: [0, 1],
   16: [1, 1, 0, 0, 1],
   17: [0, 1],
   19: [0, 1],
}

function mod(x, m) {
    // Returns the unique integer between 0 and |m|-1 which is equal to x in Z_m
    // Assumes that x and m are integers and m is nonzero
    return (x % m + Math.abs(m)) % m;
}

class Polynomial {
    // Stores a polynomial as an array of coefficiencts, where coeffs[i] is the coefficient of x^i
    // Assumes the polynomial is over the field Z_p, where the modulus p is prime
    constructor(modulus, coeffs) {
        this.modulus = modulus;
        this.coeffs = coeffs.map(x => mod(x, modulus));
        this.strip_leading_zeros();
    }
    strip_leading_zeros() {
        while (this.coeffs[this.coeffs.length - 1] == 0) {
            this.coeffs.pop();
        }
    }
    deg() {
        // Returns degree of the polynomial
        this.strip_leading_zeros();
        return this.coeffs.length - 1;
    }
    neg() {
        // Returns additive inverse
        return new Polynomial(this.modulus, this.coeffs.map(x => -x));
    }
    add(f) {
        // Returns this plus f, where f is another Polynomial
        console.assert(f.modulus == this.modulus);
        var sum_coeffs = [];
        for (var i = 0; i <= Math.min(this.deg(), f.deg()); i++) {
            sum_coeffs.push(this.coeffs[i] + f.coeffs[i]);
        }
        sum_coeffs.push(... this.coeffs.slice(Math.min(this.deg(), f.deg()) + 1));
        sum_coeffs.push(...    f.coeffs.slice(Math.min(this.deg(), f.deg()) + 1));
        return new Polynomial(this.modulus, sum_coeffs);
    }
    sub(f) {
        // Returns this minus f, where f is another Polynomial
        return this.add(f.neg());
    }
    mul(f) {
        // Returns this times f, where f is another Polynomial
        console.assert(f.modulus == this.modulus);
        var prod_coeffs = [];
        for (var i = 0; i <= this.deg() + f.deg(); i++) {
            prod_coeffs.push(0);
            for (var j = 0; j <= i; j++) {
                if (j > this.deg() || i-j > f.deg()) {
                    continue;
                }
                prod_coeffs[i] += this.coeffs[j] * f.coeffs[i - j];
            }
        }
        return new Polynomial(this.modulus, prod_coeffs);
    }
    quotient(f) {
        // Returns quotient by of this by the ideal generated by the monic Polynomial f,
        // expressed as a representative element whose degree is lower than the degree of f
        console.assert(f.coeffs[f.coeffs.length - 1] == 1);
        console.assert(f.modulus == this.modulus);
        return this.sub(f.mul(new Polynomial(this.modulus, this.coeffs.slice(f.deg()))));
    }
}

class FiniteField {
    /* Defines addition and multiplication of elements in the finite field of order q=p^n,
    where p is a prime number and n is a positive integer. The field is represented as

    F_{p^n} := F_{p}[x]/<f(x)>,

    where f(x) is a degree n (monic) irreducible polynomial over F_p.
    Let r be any root of f, so f(r)=0. Then any element of the field F_{p^n} can be
    uniquely represented by the polynomial

    a_0 + a_1 r + a_2 r^2 + ... + a_{n-1} r^{n-1},

    which makes addition and multiplication behave the way they should. That same
    element can also be represented as a single integer in [0, p^n - 1]:

    a_0 + a_1 p + a_2 p^2 + ... + a_{n-1} p^{n-1}.

    That integer representation does not make addition and multiplication work the way
    they should, but it is more convenient and human-readable. */
    constructor(q) {
        this.q = q
        this.p = prime_powers[q][0];
        this.n = prime_powers[q][1];
        this.cache = {};
        this.modulus = new Polynomial(this.p, q_to_poly[q]);
    }
    int_to_poly(num) {
        // Convert an integer to a polynomial with coefficients in F_p
        var poly_coeffs = [];
        for (var i = 0; i < this.n; i++) {
            poly_coeffs.push(num % this.p);
            num = Math.floor(num / this.p);
        }
        return new Polynomial(this.p, poly_coeffs);
    }
    poly_to_int(poly) {
        // Convert a polynomial to an integer using base p encoding
        var integer_form = 0;
        for (var i = 0; i < poly.coeffs.length; i++) {
            integer_form += poly.coeffs[i] * (this.p ** i);
        }
        return integer_form;
    }
    add(a, b) {
        // Add two field elements (given as integers)
        if (a+'+'+b in this.cache) {
            return this.cache[a+'+'+b];
        }
        let poly_a = this.int_to_poly(a);
        let poly_b = this.int_to_poly(b);
        let poly_sum = poly_a.add(poly_b).quotient(this.modulus);
        let a_plus_b = this.poly_to_int(poly_sum);
        this.cache[a+'+'+b] = a_plus_b
        this.cache[b+'+'+a] = a_plus_b
        return a_plus_b
    }
    mul(a, b) {
        // Multiply two field elements (given as integers)
        if (a+'*'+b in this.cache) {
            return this.cache[a+'*'+b];
        }
        let poly_a = this.int_to_poly(a);
        let poly_b = this.int_to_poly(b);
        let product = poly_a.mul(poly_b).quotient(this.modulus);
        let a_times_b = this.poly_to_int(product);
        this.cache[a+'*'+b] = a_times_b;
        this.cache[b+'*'+a] = a_times_b;
        return a_times_b;
    }
    neg(a) {
        // Returns additive inverse of a
        if ('-'+a in this.cache) {
            return this.cache['-'+a];
        }
        for (var i = 0; i < this.q; i++) {
            if (this.add(a, i) == 0) {
                this.cache['-'+a] = i;
                this.cache['-'+i] = a;
                return i;
            }
        }
    }
    inv(a) {
        // Returns multiplicative inverse of a
        if ("1/"+a in this.cache) {
            return this.cache["1/"+a];
        }
        for (var i = 0; i < this.q; i++) {
            if (this.mul(a, i) == 1) {
                this.cache["1/"+a] = i;
                this.cache["1/"+i] = a;
                return i;
            }
        }
    }
    div(a, b) {
        return this.mul(a, this.inv(b));
    }
}

class IncidenceStructure {
    // Pretty much the same as a hypergraph, except the hyperedges are called lines.
    // Vertices are labeled as integers from 0 to V-1, and lines are sets of vertices
    constructor(V, lines = []) {
        this.V = V;
        this.lines = lines;
    }
    dual() {
        // Returns a new incidence structure, equal to the dual of this one
        const dual_structure = new IncidenceStructure(
            this.lines.length,
            Array(this.V).fill(null).map(() => [])
        );
        // l is the index of the line in this IncidenceStructure, and
        // v is the index of the vertex in this.lines[l]
        for (let l = 0; l < this.lines.length; l++) {
            for (let v = 0; v < this.lines[l].length; v++) {
                let vertex = this.lines[l][v];
                dual_structure.lines[vertex].push(l);
            }
        }
        return dual_structure;
    }
}

class ProjectivePlane extends IncidenceStructure {
    // Generates the projective plane consisting of:
    // q^2+q+1 lines, which each contain q+1 points, and
    // q^2+q+1 points, which are each contained in q+1 different lines.
    // Points are labeled as integers in [0, q^2+q], and lines are
    // represented as sets of those integers.
    constructor(q) {
        let F = new FiniteField(q);
        let V = q**2 + q + 1;
        let lines = Array.from({length: V}, () => []);

        // Each triple can either represent a point with coordinates (x, y, z) or
        // a line with the equation ax+by+cz=0 and coefficients (a, b, c). In
        // either case, we can assume WLOG that the first non-zero entry is 1.
        const triples = [[0, 0, 1]];
        for (let j = 0; j < q; j++) {
            triples.push([0, 1, j]);
            for (let i = 0; i < q; i++) {
                triples.push([1, i, j]);
            }
        }
        // If triples[i] is [a,b,c], then we want lines[i] to be the set of triples
        // [x,y,z] such that ax+by+cz=0.
        for (let i = 0; i < V; i++) {
            let [a, b, c] = triples[i];
            if (a == 1) {
                // If a=1, then the equation ax+by+cz=0 becomes x+by+cz=0, and we
                // can assume WLOG that x=1, so it becomes 1+by+cz=0. One solution is
                // (0, 1, -b/c), unless c=0, in which case (0, 0, 1) is a solution.
                if (c == 0) {
                    lines[i] = [[0, 0, 1]];
                } else {
                    lines[i].push([0, 1, F.neg(F.div(b, c))]);
                }
                // The remaining solutions can be parameterized by y to obtain
                // (1, y, -(1+by)/c), unless c=0. If c=0 and b is nonzero, the
                // remaining solutions can be parameterized by z as (1, -1/b, z),
                // but if b=c=0, they are parameterized by y as (0, 1, z)
                if (c == 0 && b == 0) {
                    for (let z = 0; z < q; z++) {
                        lines[i].push([0, 1, z]);
                    }
                } else if (c == 0) {
                    for (let z = 0; z < q; z++) {
                        lines[i].push([1, F.neg(F.inv(b)), z]);
                    }
                } else {
                    for (let y = 0; y < q; y++) {
                        lines[i].push([1, y, F.neg(F.div(F.add(1, F.mul(b, y)), c))]);
                    }
                }
            } else if (b == 1) {
                // If a=0 and b=1, then equation becomes y+cz=0, and since y is the
                // first non-zero coordinate, we can choose the representative
                // element with y=1. Then the line contains the point
                // (0, 1, -1/c), unless c=0, in which case it contains (0, 0, 1)
                if (c == 0) {
                    lines[i] = [[0, 0, 1]];
                } else {
                    lines[i] = [[0, 1, F.neg(F.inv(c))]];
                }
                // For the remaining solutions, assume x=1, so the equation is
                // y+cz=0. The remaining solutions can be parameterized by y,
                // so they have the form (1, y, -y/c), unless c=0, in which case
                // they have the form (1, 0, z)
                if (c == 0) {
                    for (let z = 0; z < q; z++) {
                        lines[i].push([1, 0, z]);
                    }
                } else {
                    for (let y = 0; y < q; y++) {
                        lines[i].push([1, y, F.neg(F.div(y, c))]);
                    }
                }
            } else {
                // In this case, a=b=0, so the equation ax+by+cz=0 becomes
                // cz=0. Therefore z=0, but x and y can be anything. Since we
                // only include the representative element where the first
                // nonzero coordinate is 1, either x=1 and y can be anything,
                // or x=0 and y=1.
                lines[i] = [[0, 1, 0]];
                for (let y = 0; y < q; y++) {
                    lines[i].push([1, y, 0]);
                }
            }
        }
        // Create a bijection from triples [x,y,z] (assuming we use the representative
        // element where the first nonzero entry of [x,y,z] is 1) to integers in
        // [0, V)
        const relabeled_points = {};
        for (let i = 0; i < V; i++) {
            let [x, y, z] = triples[i];
            relabeled_points[x+','+y+','+z] = i;
        }
        const relabeled_lines = [];
        for (let i = 0; i < V; i++) {
            relabeled_lines.push([]);
            for (let j = 0; j < q+1; j++) {
                // Relabel the jth point on the ith line from
                // the triple [x,y,z] to the integer xq^2+yz+z
                let [x, y, z] = lines[i][j];
                relabeled_lines[i].push(relabeled_points[x+','+y+','+z]);
            }
        }
        // Initialize this as an IncidenceStructure
        super(V, relabeled_lines);
        this.q = q;
    }
}

class AffinePlane extends IncidenceStructure {
    constructor(q) {
        // Make a temporary ProjectivePlane of order q, then remove any one line and
        // all of the vertices on that line
        let temp_proj_plane = new ProjectivePlane(q);
        let V = q**2;
        // Arbitrarily decide to remove the first line
        let vertices_to_remove = new Set(temp_proj_plane.lines[0]);
        const vertices_not_being_removed = [];
        for (let i = 0; i < temp_proj_plane.V; i++) {
            if (!(vertices_to_remove.has(i))) {
                vertices_not_being_removed.push(i);
            }
        }
        // Create dictionary from old vertex label (which is in [0, V-1], that is,
        // in [0, q^2+q]) to new vertex label (which is in [0, q^2-1])
        const relabeled_vertices = {};
        for (let i = 0; i < V; i++) {
            relabeled_vertices[vertices_not_being_removed[i]] = i;
        }
        const lines = [];
        for (let i = 1; i < temp_proj_plane.V; i++) {
            lines.push([]);
            for (let j = 0; j < q+1; j++) {
                // v is the current label for the jth vertex of the ith line
                let v = temp_proj_plane.lines[i][j];
                // If v is not one of the vertices being removed, add it to the (i-1)th
                // line of this AffinePlane
                if (!(vertices_to_remove.has(v))) {
                    lines[i-1].push(relabeled_vertices[v]);
                }
            }
        }
        // Initialize this as an IncidenceStructure
        super(V, lines);
        this.q = q;
    }
}
