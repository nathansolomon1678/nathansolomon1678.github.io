<!doctype html>
<html>
<head>
  <title>Escape-time fractals</title>
  <meta charset="utf-8"/>
  <meta name="author" content="Nathan Solomon">
  <meta name="description" content="Playground for creating pictures of various escape-time fractals">
  <meta name="keywords" content="fractals, escape-time, mandelbrot, heart, burning ship, julia">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="website_fashion_police.css" rel="stylesheet" type="text/css"/>
  <script src="nasty_heccin_javascript.js" type="text/javascript"> </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<!-- The following HTML is taken from https://morotsman.github.io/blog,/google/analytics,/jekyll,/github/pages/2020/07/07/add-google-analytics.html -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-206139197-1"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-206139197-1');
</script>

<body onresize="redraw()">
  <button id=openSidebarButton onclick="openSidebar()" style="float: left; display: none; position: absolute">
    open<br>sidebar
  </button>
  <div id="theDivWithAllTheStuff" style="display: block">
    <button id=hideSidebarButton onclick="hideSidebar()" style="float: right">
      close<br>sidebar
    </button>
    <h1>Escape-time fractals</h1>
    <h2>Settings</h2>
    <ul>
      <li>
        <label for="fractal type">Fractal type:</label>
        <select id="fractal type" onchange="redraw()">
          <option value=0 selected="selected">Mandelbrot</option>
          <option value=1>Heart</option>
          <option value=2>Burning ship</option>
        </select>
      </li>
      <li>
        <label for="colorscheme">Colorscheme: </label>
        <select id="colorscheme" onchange="redraw()">
          <option value=0>Classic</option>
          <option value=1>Experimental</option>
          <option value=2 selected="selected">Rachel's</option>
          <option value=3>Sherbet</option>
        </select>
      </li>
      <li>
        <label for="colorfulness">Colorfulness: </label>
        <input id="colorfulness" type="number" value=20 min=-100 max=100 step=1 onchange="redraw()">
      </li>
      <li>
        <label for="color offset">Color offset: </label>
        <input id="color offset" type="range" class="slider" value=0 onchange="redraw()">
      </li>
    </ul>
    <button id="julify" onclick="toggle_julia_set()">
      Show Julia set modification of fractal (instead of the original)
    </button>
    <br>
    <br>
    <code id="display view settings">Loading...</code>

    <h2>Advanced Settings</h2>
    <ul>
      <li>
        <label for="coloring method">Coloring method:</label>
        <select id="coloring method" onchange="redraw()">
          <option value=0 selected="selected">Terraced</option>
          <option value=1>Smooth</option>
          <option value=2>Interior</option>
          <option value=3>Rings</option>
        </select>
      </li>
      <li>
        <label for="max iterations">Max iterations: </label>
        <input id="max iterations" type="number" value=200 min=0 max=5000 step=1 onchange="redraw()">
      </li>
      <li>
        <label for="divergnce threshold">Divergence threshold: </label>
        <input id="divergence threshold" type="number" value=1000000 min=0 max=1000000 step=.1 onchange="redraw()">
      </li>
    </ul>

    <h2>Save image settings</h2>
    <a id="URL" href="">https://nathansolomon1678.github.io/fractals</a>

    <h2>How do I use this site?</h2>
      <h3>...on a phone / tablet</h3>
        <p>You don't. Since the beauty of fractals lies in their infinite detail, instead of their overall shapes and colors, the only way to appreciate this site is to visit it on a computer.</p>
      <h3>...on a computer</h3>
      <p><ul>
        <li>Scroll to zoom</li>
        <li>Click & drag to pan</li>
        <li>Right-click to save or copy the image on the canvas</li>
        <li>Left-click to place the crosshair (explanation below)</li>
      </ul></p>

    <h2>What are escape-time fractals?</h2>
    <p>See these links for great explanations:<br>
    <ul>
      <li><a href="https://morr.cc/mandelbrot/">https://morr.cc/mandelbrot/</a></li>
      <li><a href="https://acko.net/blog/how-to-fold-a-julia-fractal/">https://acko.net/blog/how-to-fold-a-julia-fractal/</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Fractal">This wikipedia article</a></li>
    </ul>
    </p>

    <h2>Crosshair & Julia sets</h2>
    <p>Click on the canvas to place a crosshair, than click the "show Julia set" button to create another fractal based on how the original fractal looks near that point. For example, if you place the crosshair at a zigzaggy-lightningy region of the Mandelbrot fractal, the corresponding Julia fractal will be zigzaggy and lightningy everywhere. If you place it at a spirally region, the entire Julia set will be spirally. If you can't place the crosshair by clicking, toggle the "show orginal" button to go back to the original fractal.</p>

  </div>

  <canvas id="theCanvas" onwheel="zoom(event)" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)" onmousemove="mouse_move(event)">
    Your browser does not seem to support HTML5 canvas.
  </canvas>

  <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
    precision highp float;
    in vec2 position;
    out vec2 vertex_position;
    void main() {
      gl_Position = vec4(position, 0., 1.);
      vertex_position = position;
    }
  </script>

  <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
    precision highp float;
    in vec2 vertex_position;
    out vec4 fragmentColor;

    uniform vec2 crosshair;
    uniform vec2 canvas_dimensions;
    uniform vec2 center;
    uniform float scale_factor;
    uniform int max_iterations;
    uniform float divergence_threshold;
    uniform int fractal_type;
    uniform int colorscheme;
    uniform float colorfulness;
    uniform int coloring_method;
    uniform float color_offset;
    uniform float julification;
    uniform float heartiness;
    uniform bool julify;

    float square(float x) { return x * x; }
    float magnitude(vec2 z) {
      return sqrt(square(z.x) + square(z.y));
    }

    float cubic_interpolation(float a, float b, float c, float d, float x) {
      // Returns f(x), where f is a cubic function, f(-1)=a, f(0)=b, f(1)=c, & f(2)=d
      return b +
             x * (.5 * c - .5 * a) +
             x * x * (a - 2.5 * b + 2. * c - .5 * d) +
             x * x * x * (-.5 * a + 1.5 * b - 1.5 * c + .5 * d);
    }

    vec3 mix_cubic(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float x) {
      return vec3(cubic_interpolation(color0.r, color1.r, color2.r, color3.r, x),
                  cubic_interpolation(color0.g, color1.g, color2.g, color3.g, x),
                  cubic_interpolation(color0.b, color1.b, color2.b, color3.b, x));
    }

    // COLORSCHEMES
    vec3 classic_colorscheme(float x) {
      x *= 6.28318530718;
      return vec3(.5 + sin(x     ) / 2.,
                  .5 + sin(x + 1.) / 2.,
                  .5 + sin(x + 2.) / 2.);
    }
    vec3 experimental_colorscheme(float x) {
      vec3 navy    = vec3(.1, 0., .3);
      vec3 magenta = vec3(.6, .2, .4);
      vec3 gold    = vec3(1., 1., .7);
      vec3 green   = vec3(.2, .8, .4);
      x = fract(x) * 4.;
           if (x < 1.) { return mix_cubic(magenta, navy   , green  , gold   , fract(x)); }
      else if (x < 2.) { return mix_cubic(navy   , green  , gold   , magenta, fract(x)); }
      else if (x < 3.) { return mix_cubic(green  , gold   , magenta, navy   , fract(x)); }
      else if (x < 4.) { return mix_cubic(gold   , magenta, navy   , green  , fract(x)); }
      else             { return navy; }
    }
    vec3 rachels_colorscheme(float x) {
      vec3 maroon = vec3(.2, .0, .1);
      vec3 orange = vec3(1., .5, .1);
      vec3 purple = vec3(.1, 0., .3);
      vec3 white  = vec3(1., 1., 1.);
      x = fract(x) * 4.;
           if (x < 1.) { return mix_cubic(purple, maroon, orange, white , fract(x)); }
      else if (x < 2.) { return mix_cubic(maroon, orange, white , purple, fract(x)); }
      else if (x < 3.) { return mix_cubic(orange, white , purple, maroon, fract(x)); }
      else if (x < 4.) { return mix_cubic(white , purple, maroon, orange, fract(x)); }
      else             { return maroon; }
    }
    vec3 sherbet_colorscheme(float x) {
      vec3 grape   = vec3(.43, .08, .74);
      vec3 magenta = vec3(.55, .25, .40);
      vec3 peach   = vec3(.91, .64, .48);
      vec3 blue    = vec3(.36, .51, .55);
      vec3 green   = vec3(.12, .25, .26);
      x = fract(x) * 5.;
           if (x < 1.) { return mix_cubic(grape  , magenta,   peach,    blue, fract(x)); }
      else if (x < 2.) { return mix_cubic(magenta, peach  ,    blue,   green, fract(x)); }
      else if (x < 3.) { return mix_cubic(peach  , blue   ,   green,   grape, fract(x)); }
      else if (x < 4.) { return mix_cubic(blue   , green  ,   grape, magenta, fract(x)); }
      else if (x < 5.) { return mix_cubic(green  , grape  , magenta,   peach, fract(x)); }
      else             { return magenta; }
    }

    vec4 color(float x) {
      float real_colorfulness = colorfulness;
      if (coloring_method == 0 || coloring_method == 1) {
        real_colorfulness /= 5000.;
      } else if (coloring_method == 2) {
        real_colorfulness /= 100.;
      } else {
        real_colorfulness /= 150.;
      }
      x = x * real_colorfulness + color_offset;

      if (colorscheme == 0) {
        return vec4(classic_colorscheme(x), 1);
      } else if (colorscheme == 1) {
        return vec4(experimental_colorscheme(x), 1.);
      } else if (colorscheme == 2) {
        return vec4(rachels_colorscheme(x), 1.);
      } else if (colorscheme == 3) {
        return vec4(sherbet_colorscheme(x), 1.);
      }
    }

    void draw_crosshair(vec2 center, vec2 pixel_coord, vec3 color) {
      float distance_to_center = magnitude(center - pixel_coord) * scale_factor;
      if (distance_to_center > .14 && distance_to_center < .15 ||
          distance_to_center > .08 && distance_to_center < .085) {
        fragmentColor = vec4(color, 1.);
        return;
      }
      float angle = atan(pixel_coord.y - center.y,
                         pixel_coord.x - center.x);
      if (distance_to_center > abs(sin(angle * 2.)) && distance_to_center < .17 && distance_to_center > .03) {
        fragmentColor = vec4(color, 1.);
      }
    }

    vec2 iterate(vec2 z, vec2 c, int type) {
      if (type == 0) {
        // Mandelbrot
        return c + vec2(square(z.x) - square(z.y),
                        2. * z.x * z.y);
      } else if (type == 1) {
        // Heart
        return c + vec2(z.x * z.y,
                        abs(z.y) - abs(z.x));
      } else if (type == 2) {
        // Burning ship
        return c + vec2(square(z.x) - square(z.y),
                        -abs(2. * z.x * z.y));
      }
    }

    void main() {
      vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
      vec2 original_z = vertex_position * window / scale_factor + center;
      vec2 last_z = original_z;
      vec2 z = original_z;
      float distance_to_orbit_trap = 1000000.;
      for (int i = 0; i <= max_iterations; i++) {
        if (julify) {
          z = iterate(z, crosshair, fractal_type);
        } else {
          z = iterate(z, original_z, fractal_type);
        }
        if (coloring_method == 0) {
          // Color by how many iterations it takes to diverge
          if (magnitude(z) > divergence_threshold) {
            fragmentColor = color(float(i));
            break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 1) {
          // Same as above, but smooth instead of terraced
          if (magnitude(z) > divergence_threshold) {
            float float_iters = float(i) + log(divergence_threshold / magnitude(last_z)) /
                                           log(magnitude(z) / magnitude(last_z));
            fragmentColor = color(float_iters);
            break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 2) {
          // Color by the log of the magnitude after iterating a whole bunch
          if (magnitude(z) > divergence_threshold) {
            fragmentColor = vec4(0., 0., 0., 1.);
            break;
          } else {
            fragmentColor = color(log(magnitude(z)));
          }
        } else if (coloring_method == 3) {
          // Color based on how close z gets to a ring around the origin with radius equal to the divergence threshold
          distance_to_orbit_trap = min(distance_to_orbit_trap, abs(magnitude(z) - divergence_threshold));
          fragmentColor = color(-log(distance_to_orbit_trap));
        }
        last_z = z;
      }
      if (!julify) {
        draw_crosshair(crosshair, original_z, vec3(1.) - fragmentColor.xyz / 3.);
      }
    }
  </script>
</body>
</html>
