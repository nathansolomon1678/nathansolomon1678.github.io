<!doctype html>
<html>
<head>
  <title>Escape-time fractals</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="website_fashion_police.css" rel="stylesheet" type="text/css"/>
  <script src="nasty_heccin_javascript.js" type="text/javascript"> </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <!-- There are separate buttons for dismissing and reopening the sidebar,
  but only one of them will be visible at a time. This one starts hidden. -->
  <button id=showSidebarButton onclick="showSidebar()" style="float: left; display: none; position: absolute">
    show<br>sidebar
  </button>
  <div id="theDivWithAllTheStuff" style="display: block">
    <button id=hideSidebarButton onclick="hideSidebar()" style="float: right">
      close<br>sidebar
    </button>
    <h1>Escape-time fractals</h1>
    <h2>Settings</h2>
    <label for="fractalType">Fractal type:</label>
    <select id="fractalType" onchange="redraw()" class="setting">
      <option value=0>Mandelbrot</option>
      <option value=1>Heart</option>
      <option value=2>Burning ship</option>
      <option value=3>Collatz</option>
      <option value=4 selected="selected">Untitled 1</option>
    </select>
    <br>
    <label for="coloringMethod">Coloring method:</label>
    <select id="coloringMethod" onchange="redraw()" class="setting">
      <option value=0 selected="selected">Outside of shape</option>
      <option value=1>Inside of shape</option>
    </select>
    <br>
    <label for="julify">Show Julia set instead of original: </label>
    <input type="checkbox" id="julify" onchange="redraw()" class="setting">
    <br>
    <label for="maxIters">Maximum iterations: </label>
    <input id="maxIters" type="number" value=100 min=0 max=150 step=1 onchange="redraw()" class="setting">
    <br>
    <label for="logDivergenceLimit">log(Divergence limit): </label>
    <input id="logDivergenceLimit" type="number" value=5 min=-5 max=20 step=.2 onchange="redraw()" class="setting">
    <br>
    <label for="colorscheme">Colorscheme: </label>
    <select id="colorscheme" onchange="redraw()" class="setting">
      <option value=0 selected="selected">Default</option>
      <option value=1>Rainbow</option>
    </select>
    <br>
    <label for="colorfullness">Colorfullness: </label>
    <input id="colorfullness" type="number" value=.2 min=0 max=10 step=.01 onchange="redraw()" class="setting">
    <h2>How do I use this site?</h2>
    <h3>...on a phone / tablet</h3>
    <p>You don't. Since the beauty of fractals lies in their infinite detail, instead of their overall shapes and colors, the only way to appreciate this site is to visit it on a computer.</p>
    <h3>...on a computer</h3>
    <p>Hah idk either lol. I'll change the controls later, but for now, just move the mouse to change the constant for the Julia sets, and scroll to zoom. The zooming in is sorta weird currently; I hope to fix that soom.</p>
    <h2>What are fractals?</h2>
    <p>Fractals are pretty nifty. <a href="https://en.wikipedia.org/wiki/Fractal">This wikipedia article</a> can explain them a whole lot better than I can.</p>
    <p>This website focuses on escape-time fractals, such as the famous Mandelbrot set. These fractals are generated by assigning each pixel an initial \(x\) and \(y\) value, based on their coordinates. Then we repeatedly apply a function to that \((x,y)\) point. That repeated mapping will cause some points to go off to infinity (diverge), but not others. We then color the pixel based off of how long it takes to diverge, or whether it diverges at all.</p>
    <h3>Further reading</h3>
    <p>These links below have beautiful and intuitive explanations of the Mandelbrot and Julia sets, respectively:
    <a href="https://morr.cc/mandelbrot/">https://morr.cc/mandelbrot/</a><br>
    <a href="https://acko.net/blog/how-to-fold-a-julia-fractal/">https://acko.net/blog/how-to-fold-a-julia-fractal/</a>
    </p>
    <h2>What do all these settings mean?</h2>
    <h3>Fractal type</h3>
    <p>The fractal type is defined by the function repeatedly applied to points. \((x_0,y_0)\) refers to the initial coordinates of the pixel.</p>
    <h3>Coloring method</h3>
    <h3>Julia set</h3>
    <h3>Maximum iterations</h3>
    <h3>Divergence limit</h3>
    <h2>What are these types of fractals?</h2>
    <h3>Mandelbrot</h3>
    <p>$$ x_{n+1} = x_n^2 - y_n^2 + x_0 $$</p>
    <p>$$ y_{n+1} = 2 x_n y_n + y_0 $$</p>
    <p>The Mandelbrot fractal is nice because it has a stunningly simple interpretation using complex numbers. If we treat each pixel as a complex number \(z=x+iy\) instead of an \((x,y)\) point, those two equations become:</p>
    <p>$$ z_{n+1} = z_n^2 + z_0 $$</p>
    <h3>Heart</h3>
    <p>$$ x_{n+1} = x_n * y_n + x_0 $$</p>
    <p>$$ y_{n+1} = |y_n| - |x_n| + y_0 $$</p>
    <p>The heart fractal is my personal favorite because I found it myself (by randomly fiddling around)! And because it's a heart!</p>
    <h3>Burning ship</h3>
    <p>$$ x_{n+1} = x_n^2 - y_n^2 + x_0 $$</p>
    <p>$$ y_{n+1} = -2 |x_n y_n| + y_0 $$</p>
    <h3>Collatz</h3>
    <p>The currently unproven Collatz Conjecture states that for any natural number \(z\), repeatedly mapping this function will eventually get \(z\) to one:
    <p>$$ z_{n+1} = \begin{cases} z_n / 2 & \text{if $z_n$ is even} \\
                                  3 z_n + 1 & \text{if $z_n$ is odd} \end{cases} $$</p>
    <p>This can be generalized to all \(z \in \Bbb C\) as shown below:</p>
    <p>$$ z_{n+1} = \Big( \frac {z_n} {2} \Big) \cos^2 \Big( \frac {\pi} {2} z_n \Big) + (3 z_n + 1) \sin^2 \Big( \frac {\pi} {2} z_n \Big) $$</p>
    <p>Here, we're once again treating the \((x,y)\) point as a single number \(z=x+iy\)</p>
    <p>Note that there is not a Julia set modification of the Collatz fractal, since that equation does not inculde a \(z_0\) term.<p>
    <h3>Untitled 1</h4>
    <p>$$ x_{n+1} = |y_n| - |x_n| + x_0 $$</p>
    <p>$$ y_{n+1} = x_n * |y_n| + y_0 $$</p>
    <h2>Credits & stuff</h2>
    <p>For more info, go back to <a href="https://nathansolomon1678.github.io">the home page</a> of this site.</p>
    <p>Note that this website is currently incomplete. If you couldn't tell, I guess I'll take that as a compliment.</p>
  </div>
  <canvas id="theCanvas" onwheel="zoom(event)">
    Your browser does not seem to support HTML5 canvas.
  </canvas>
  <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
    precision highp float;
    
    in vec2 position;
    out vec2 vertex_position;
    
    void main() {
      gl_Position = vec4(position, 0., 1.);
      vertex_position = position;
    }
  </script>
  <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
    precision highp float;
    in vec2 vertex_position;
    out vec4 fragmentColor;
    
    uniform vec2 complex_constant;
    uniform vec2 canvas_dimensions;
    uniform vec2 center;
    uniform float scale_factor;
    uniform int coloring_method;
    uniform int max_iterations;
    uniform float log_divergence_limit;
    uniform int fractal_type;
    uniform int julify;
    uniform int colorscheme;
    uniform float colorfullness;

    const float pi = 3.14159265;
    float square(float x) { return x * x; }
    // Functions for complex numbers:
    vec2 cosine(vec2 z) {
      return vec2( cos(z.x) * cosh(z.y),
                  -sin(z.x) * sinh(z.y));
    }
    vec2 sine(vec2 z) {
      return vec2( sin(z.x) * cosh(z.y),
                   cos(z.x) * sinh(z.y));
    }
    vec2 multiply(vec2 z, vec2 s) {
      return vec2(z.x * s.x - z.y * s.y,
                  z.x * s.y + z.y * s.x);
    }
    vec2 square(vec2 z) {
      return multiply(z, z);
    }
    
    // COLORSCHEMES
    vec3 default_colo(float x) {
      return vec3(.5 + sin(x     ) / 2.,
                  .5 + sin(x + 1.) / 2.,
                  .5 + sin(x + 2.) / 2.);
    }
    vec3 rainbow(float x) {
      x = fract(x / 6.) * 6.;
           if (x < 1.) { return vec3(1.           , fract(x)     , 0.           ); }
      else if (x < 2.) { return vec3(1. - fract(x), 1.           , 0.           ); }
      else if (x < 3.) { return vec3(0.           , 1.           , fract(x)     ); }
      else if (x < 4.) { return vec3(0.           , 1. - fract(x), 1.           ); }
      else if (x < 5.) { return vec3(fract(x)     , 0.           , 1.           ); }
      else             { return vec3(1.           , 0.           , 1. - fract(x)); }
    }
    vec4 color(float x) {
      x *= colorfullness;
      if (colorscheme == 0) {
        return vec4(default_colo(x), 1);
      } else if (colorscheme == 1) {
        return vec4(rainbow(x), 1.);
      }
    }

    vec2 iterate(vec2 z, vec2 c, int type) {
      if (type == 0) {
        // Mandelbrot
        return c + square(z);
      } else if (type == 1) {
        // Heart
        return c + vec2(z.x * z.y,
                        abs(z.y) - abs(z.x));
      } else if (type == 2) {
        // Burning ship
        return c + vec2(square(z.x) - square(z.y),
                        -abs(2. * z.x * z.y));
      } else if (type == 3) {
        // Collatz thingy
        return multiply(z / 2., square(cosine(pi/ 2. * z))) + multiply(3. * z + vec2(1., 0.), square(sine(pi / 2. * z)));
      } else if (type == 4) {
        // Untitled 1
        return c + vec2(abs(z.y) - abs(z.x),
                        z.x * abs(z.y));
      }
    }
    
    void main() {
      vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
      vec2 z = vertex_position * window / scale_factor + center;
      vec2 original_z = z;
      float magnitude = sqrt(square(z.x) + square(z.y));
      for (int i = 0; i <= max_iterations; i++) {
        float last_magnitude = magnitude;
        if (julify == 0) {
          // Don't julify
          z = iterate(z, original_z, fractal_type);
        } else if (julify == 1) {
          // Julify
          z = iterate(z, complex_constant, fractal_type);
        }
        magnitude = sqrt(square(z.x) + square(z.y));
        if (coloring_method == 0) {
          // Color by how many iterations it takes to diverge
          if (log(magnitude) > log_divergence_limit) {
            float float_iters = float(i) + (log_divergence_limit - log(last_magnitude)) /
                                           (log(magnitude) - log(last_magnitude));
            fragmentColor = color(float_iters);
          break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 1) {
          // Color by the log of the magnitude after interating a whole bunch
          if (log(magnitude) > log_divergence_limit) {
            fragmentColor = vec4(0., 0., 0., 1.);
            break;
          } else {
            fragmentColor = color(log(magnitude));
          }
        }
      }
    }
  </script>
</body>
</html>
