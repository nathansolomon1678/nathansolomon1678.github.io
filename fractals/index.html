<!doctype html>
<html>
<head>
  <title>Escape-time fractals</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="website_fashion_police.css" rel="stylesheet" type="text/css"/>
  <script src="nasty_heccin_javascript.js" type="text/javascript"> </script>
</head>
<body>
  <div id="theDivWithAllTheStuff" style="display: block">
    <h1>Escape-time fractals</h1>
    <h2>Settings</h2>
    <label for="fractalType">Fractal type:</label>
    <select id="fractalType" onchange="redraw()">
      <option value=0>Mandelbrot</option>
      <option value=1>Heart</option>
      <option value=2>Burning ship</option>
      <option value=3>Collatz</option>
      <option value=4 selected="selected">Untitled 1</option>
    </select>
    <br>
    <label for="coloringMethod">Coloring method:</label>
    <select id="coloringMethod" onchange="redraw()">
      <option value=0 selected="selected">Outside of shape</option>
      <option value=1>Inside of shape</option>
    </select>
    <br>
    <label for="julify">Show julia set: </label>
    <input type="checkbox" id="julify" checked onchange="redraw()">
    <br>
    <label for="logScaleFactor">log(Scale factor): </label>
    <input id="logScaleFactor" type="number" value=-1 min=-5 max=20 step=.1 onchange="redraw()">
    <br>
    <label for="maxIters">Maximum iterations: </label>
    <input id="maxIters" type="number" value=100 min=1 max=100 step=1 onchange="redraw()">
    <br>
    <label for="logDivergenceLimit">log(Divergence limit): </label>
    <input id="logDivergenceLimit" type="number" value=5 min=-5 max=20 step=.1 onchange="redraw()">
    <br>
    <label for="colorscheme">Colorscheme: </label>
    <select id="colorscheme" onchange="redraw()">
      <option value=0 selected="selected">Default</option>
      <option value=1>Rainbow</option>
    </select>
    <br>
    <label for="colorfullness">Colorfullness: </label>
    <input id="colorfullness" type="number" value=.15 min=.01 max=1 step=.01 onchange="redraw()">
    <h2>What are fractals?</h2>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
  </div>
  <canvas id="theCanvas">Your browser does not seem to support HTML5 canvas.</canvas>
  <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
    precision highp float;
    
    in vec2 position;
    out vec2 vertex_position;
    
    void main() {
      gl_Position = vec4(position, 0., 1.);
      vertex_position = position;
    }
  </script>
  <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
    precision highp float;
    in vec2 vertex_position;
    out vec4 fragmentColor;
    
    uniform vec2 complex_constant;
    uniform vec2 canvas_dimensions;
    uniform float scale_factor;
    uniform int coloring_method;
    uniform int max_iterations;
    uniform float log_divergence_limit;
    uniform int fractal_type;
    uniform int julify;
    uniform int colorscheme;
    uniform float colorfullness;

    const float pi = 3.14159265;
    float square(float x) { return x * x; }
    // Functions for complex numbers:
    vec2 cosine(vec2 z) {
      return vec2( cos(z.x) * cosh(z.y),
                  -sin(z.x) * sinh(z.y));
    }
    vec2 sine(vec2 z) {
      return vec2( sin(z.x) * cosh(z.y),
                   cos(z.x) * sinh(z.y));
    }
    vec2 multiply(vec2 z, vec2 s) {
      return vec2(z.x * s.x - z.y * s.y,
                  z.x * s.y + z.y * s.x);
    }
    vec2 square(vec2 z) {
      return multiply(z, z);
    }
    
    // COLORSCHEMES
    vec3 default_colo(float x) {
      return vec3(.5 + sin(x     ) / 2.,
                  .5 + sin(x + 1.) / 2.,
                  .5 + sin(x + 2.) / 2.);
    }
    vec3 rainbow(float x) {
      x = fract(x / 6.) * 6.;
           if (x < 1.) { return vec3(1.           , fract(x)     , 0.           ); }
      else if (x < 2.) { return vec3(1. - fract(x), 1.           , 0.           ); }
      else if (x < 3.) { return vec3(0.           , 1.           , fract(x)     ); }
      else if (x < 4.) { return vec3(0.           , 1. - fract(x), 1.           ); }
      else if (x < 5.) { return vec3(fract(x)     , 0.           , 1.           ); }
      else             { return vec3(1.           , 0.           , 1. - fract(x)); }
    }
    vec4 color(float x) {
      x *= colorfullness;
      if (colorscheme == 0) {
        return vec4(default_colo(x), 1);
      } else if (colorscheme == 1) {
        return vec4(rainbow(x), 1.);
      }
    }

    vec2 iterate(vec2 z, vec2 c, int type) {
      if (type == 0) {
        // Mandelbrot
        return c + square(z);
      } else if (type == 1) {
        // Heart
        return c + vec2(z.x * z.y,
                        abs(z.y) - abs(z.x));
      } else if (type == 2) {
        // Burning ship
        return c + vec2(square(z.x) - square(z.y),
                        -abs(2. * z.x * z.y));
      } else if (type == 3) {
        // Collatz thingy
        return .25 * (7. * z - multiply(5. * z, cosine(pi * z)));
      } else if (type == 4) {
        // Random fiddling around v2
        return c + vec2(abs(z.y) - abs(z.x),
                        z.x * abs(z.y));
      }
    }
    
    void main() {
      vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
      vec2 z = vertex_position * window / scale_factor;
      vec2 original_z = z;
      float magnitude = sqrt(square(z.x) + square(z.y));
      for (int i = 0; i <= max_iterations; i++) {
        float last_magnitude = magnitude;
        if (julify == 0) {
          // Don't julify
          z = iterate(z, original_z, fractal_type);
        } else if (julify == 1) {
          // Julify
          z = iterate(z, complex_constant, fractal_type);
        }
        magnitude = sqrt(square(z.x) + square(z.y));
        if (coloring_method == 0) {
          // Color by how many iterations it takes to diverge
          if (log(magnitude) > log_divergence_limit) {
            float float_iters = float(i) + (log_divergence_limit - log(last_magnitude)) /
                                           (log(magnitude) - log(last_magnitude));
            fragmentColor = color(float_iters);
          break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 1) {
          // Color by the log of the magnitude after interating a whole bunch
          if (log(magnitude) > log_divergence_limit) {
            fragmentColor = vec4(0., 0., 0., 1.);
            break;
          } else {
            fragmentColor = color(log(magnitude));
          }
        }
      }
    }
  </script>
</body>
</html>
