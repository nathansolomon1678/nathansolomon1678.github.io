<!doctype html>
<html>
<head>
  <title>Escape-time fractals</title>
  <meta charset="utf-8"/>
  <meta name="author" content="Nathan Solomon">
  <meta name="description" content="Playground for creating pictures of various escape-time fractals">
  <meta name="keywords" content="fractals, escape-time, mandelbrot, heart, burning ship, julia">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="website_fashion_police.css" rel="stylesheet" type="text/css"/>
  <script src="nasty_heccin_javascript.js" type="text/javascript"> </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="shortcut icon" type="image/png" href="/favicon.png" />
</head>

<!-- The following HTML is taken from https://morotsman.github.io/blog,/google/analytics,/jekyll,/github/pages/2020/07/07/add-google-analytics.html -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-206139197-1"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-206139197-1');
</script>

<body onresize="redraw()">
  <button id=openSidebarButton onclick="openSidebar()" style="float: left; display: none; position: absolute">
    open<br>sidebar
  </button>
  <div id="theDivWithAllTheStuff" style="display: block">
    <button id=hideSidebarButton onclick="hideSidebar()" style="float: right">
      close<br>sidebar
    </button>
    <h1>Escape-time fractals</h1>
    <h2>Settings</h2>
    <ul>
      <li>
        <label for="fractal type">Fractal type:</label>
        <select id="fractal type" onchange="redraw()">
          <option value=0 selected="selected">Mandelbrot</option>
          <option value=1>Heart</option>
          <option value=2>Burning ship</option>
        </select>
      </li>
      <li>
        <label for="coloring method">Coloring method:</label>
        <select id="coloring method" onchange="redraw()">
          <option value=0 selected="selected">Terraced</option>
          <option value=1>Smooth</option>
          <option value=2>Interior</option>
          <option value=3>Rings</option>
        </select>
      </li>
      <li>
        <label for="max iterations">Max iterations: </label>
        <input id="max iterations" type="number" value=200 min=0 max=500 step=1 onchange="redraw()">
      </li>
      <li>
        <label for="divergnce threshold">Divergence threshold: </label>
        <input id="divergence threshold" type="number" value=2 min=0 max=1000000 step=.1 onchange="redraw()">
      </li>
      <li>
        <label for="colorscheme">Colorscheme: </label>
        <select id="colorscheme" onchange="redraw()">
          <option value=0>Classic</option>
          <option value=1>Experimental</option>
          <option value=2 selected="selected">Rachel's</option>
        </select>
      </li>
      <li>
        <label for="colorfulness">Colorfulness: </label>
        <input id="colorfulness" type="number" value=20 min=-100 max=100 step=1 onchange="redraw()">
      </li>
      <li>
        <label for="color offset">Color offset: </label>
        <input id="color offset" type="range" class="slider" value=0 onchange="redraw()">
      </li>
    </ul>
    <button id="julify" onclick="toggle_julia_set()">
      Show Julia set modification of fractal (instead of the original)
    </button>
    <br>
    <br>
    <code id="display view settings">Loading...</code>

    <h2>How do I use this site?</h2>
      <h3>...on a phone / tablet</h3>
        <p>You don't. Since the beauty of fractals lies in their infinite detail, instead of their overall shapes and colors, the only way to appreciate this site is to visit it on a computer.</p>
      <h3>...on a computer</h3>
      <ul>
        <li>Scroll to zoom</li>
        <li>Click & drag to pan</li>
        <li>Right-click to save or copy the image on the canvas</li>
        <li>Left-click to place the crosshair (explanation below)</li>
      </ul>

    <h2>What are fractals?</h2>
      <p><a href="https://en.wikipedia.org/wiki/Fractal">This wikipedia article</a> can explain them way better than I can.</p>
      <p>This website focuses on escape-time fractals, such as the famous Mandelbrot set. These fractals are generated by assigning each pixel \(x_0\) and \(y_0\) values, based on their initial coordinates. Then we repeatedly apply a function to that \((x,y)\) point. The function we use depends on the fractal type (see below for the equations), and whether we want the Julia set modification instead. The repeated mapping will cause some points to diverge (go off to infinity, or for practical purposes, above a threshold magnitude), but not others. We then color the pixel based off of the sequence of \(x,y\) values.</p>
      <h3>Further reading</h3>
        <p>These links below have beautiful and intuitive explanations of the Mandelbrot and Julia sets, respectively:
        <ul>
          <li><a href="https://morr.cc/mandelbrot/">https://morr.cc/mandelbrot/</a></li>
          <li><a href="https://acko.net/blog/how-to-fold-a-julia-fractal/">https://acko.net/blog/how-to-fold-a-julia-fractal/</a></li>
        </ul>
        </p>

    <h2>What do all these settings mean?</h2>
      <h3>Fractal type</h3>
        <p>The fractal type is defined by the function repeatedly applied to points. The functions are defined <a href="#types-of-fractals">here</a>.</p>
      <h3>Coloring method</h3>
        <h4>Terraced</h4>
        <p>This method colors each pixel based off of the smallest value \(n\) for which the magnitude of \((x_n, y_n)\) exceeds the divergence threshold. If it never diverges, it colors the pixel black.</p>
        <h4>Smooth</h4>
        <p>This is similar to the "Terraced" coloring method, except that it adds a correction term to smoothen out the colors. This coloring method looks best when the divergence threshold is very large.</p>
        <h4>Interior</h4>
        <p>With this method all points that diverge are colored black, and the rest are colored based on how far from the origin they get after the maximum number of iterations.</p>
        <h4>Rings</h4>
        <p>This method colors each pixel based off of the smallest distance that \((x_n,y_n)\) gets to a ring centered at the origin, with radius equal to the divergence threshold. It looks best when that threshold is below about 2.</p>
      <h3>Max iterations</h3>
        </p>This is the maximum number of times the function is applied to \((x, y)\). Lag is proportional to this value, so keep it below 100 for best performance.</p>
      <h3>Divergence threshold</h3>
        <p>This is the threshold that \(||(x, y)||\) must exceed in order to "diverge". Or if you're coloring with the "Rings" method, it's the radius of the ring.</p>
      <h3>Colorscheme, colorfulness, & color offset</h3>
        <p>These settings are purely cosmetic. Fiddle with them. See what happens.</p>
        <p>Also, note that colorfulness can be negative.</p>
      <h3>Julia set</h3>
        <p>For each point on one of the original fractals, we can create another fractal that imitates the characteristics of the original near that point. For example, if you place the crosshair at a zigzaggy-lightningy region of the Mandelbrot fractal, the corresponding Julia fractal will be zigzaggy and lightningy everywhere. If you place it at a spirally region, the entire Julia set will be spirally. Julia sets work by replacing \(x_0\) and \(y_0\) in the iterated function with constants \(c_x\) and \(c_y\) -- the \(x\) and \(y\) coordinates of the crosshair.</p>

    <h2 id="types-of-fractals">What are these types of fractals?</h2>
      <h3>Mandelbrot</h3>
        <p>The Mandelbrot fractal is objectively the most interesting and beautiful fractal that exists, even better than Romanesco broccoli.
        $$ x_{n+1} = x_n^2 - y_n^2 + x_0 $$
        $$ y_{n+1} = 2 x_n y_n + y_0 $$
        The Mandelbrot fractal is nice because it has a stunningly simple interpretation using complex numbers. If we treat each pixel as a complex number \(z=x+iy\) instead of an \((x,y)\) point, those two equations become:</p>
        <p>$$ z_{n+1} = z_n^2 + z_0 $$</p>
      <h3>Heart</h3>
        <p>This is a fractal that I found by randomly experimenting with the equations:
        $$ x_{n+1} = x_n * y_n + x_0 $$
        $$ y_{n+1} = |y_n| - |x_n| + y_0 $$
        It looks best when the divergence threshold is large.</p>
      <h3>Burning ship</h3>
        <p>This one also uses equations very similar to the Mandelbrot fractal:
        $$ x_{n+1} = x_n^2 - y_n^2 + x_0 $$
        $$ y_{n+1} = -2 |x_n y_n| + y_0 $$
        At first glance, this might not look as interesting as the other fractals. Keep looking, though -- there are some really interesting fractals to be found by coloring the interiors of its Julia sets.</p>

    <h2>Save image settings</h2>
    <a id="URL" href="">https://nathansolomon1678.github.io/fractals</a>

    <h2>This website doesn't work!</h2>
      <p>If it isn't working, and refreshing doesn't fix it, you might have WebGL disabled on your browser (it is a security risk). If that's not the problem, please open a <a href="https://github.com/nathansolomon1678/nathansolomon1678.github.io/issues/new">github issue</a> to report it.</p>

    <h2>Credits & stuff</h2>
      <p>For more info (including source code and a gallery of my favorite fractals), go back to <a href="https://nathansolomon1678.github.io">the home page</a> of this site.</p>
  </div>

  <canvas id="theCanvas" onwheel="zoom(event)" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)" onmousemove="mouse_move(event)">
    Your browser does not seem to support HTML5 canvas.
  </canvas>

  <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
    precision highp float;
    in vec2 position;
    out vec2 vertex_position;
    void main() {
      gl_Position = vec4(position, 0., 1.);
      vertex_position = position;
    }
  </script>

  <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
    precision highp float;
    in vec2 vertex_position;
    out vec4 fragmentColor;

    uniform vec2 crosshair;
    uniform vec2 canvas_dimensions;
    uniform vec2 center;
    uniform float scale_factor;
    uniform int max_iterations;
    uniform float divergence_threshold;
    uniform int fractal_type;
    uniform int colorscheme;
    uniform float colorfulness;
    uniform int coloring_method;
    uniform float color_offset;
    uniform bool julify;

    float square(float x) { return x * x; }
    float magnitude(vec2 z) {
      return sqrt(square(z.x) + square(z.y));
    }

    float cubic_interpolation(float a, float b, float c, float d, float x) {
      // Returns f(x), where f is a cubic function, f(-1)=a, f(0)=b, f(1)=c, & f(2)=d
      return b +
             x * (.5 * c - .5 * a) +
             x * x * (a - 2.5 * b + 2. * c - .5 * d) +
             x * x * x * (-.5 * a + 1.5 * b - 1.5 * c + .5 * d);
    }

    vec3 mix_cubic(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float x) {
      return vec3(cubic_interpolation(color0.r, color1.r, color2.r, color3.r, x),
                  cubic_interpolation(color0.g, color1.g, color2.g, color3.g, x),
                  cubic_interpolation(color0.b, color1.b, color2.b, color3.b, x));
    }

    // COLORSCHEMES
    vec3 classic_colorscheme(float x) {
      x *= 6.28318530718;
      return vec3(.5 + sin(x     ) / 2.,
                  .5 + sin(x + 1.) / 2.,
                  .5 + sin(x + 2.) / 2.);
    }
    vec3 experimental_colorscheme(float x) {
      vec3 navy    = vec3(.1, 0., .3);
      vec3 magenta = vec3(.6, .2, .4);
      vec3 gold    = vec3(1., 1., .7);
      vec3 green   = vec3(.2, .8, .4);
      x = fract(x) * 4.;
           if (x < 1.) { return mix_cubic(magenta, navy   , green  , gold   , fract(x)); }
      else if (x < 2.) { return mix_cubic(navy   , green  , gold   , magenta, fract(x)); }
      else if (x < 3.) { return mix_cubic(green  , gold   , magenta, navy   , fract(x)); }
      else if (x < 4.) { return mix_cubic(gold   , magenta, navy   , green  , fract(x)); }
      else             { return navy; }
    }
    vec3 rachels_colorscheme(float x) {
      vec3 maroon = vec3(.2, .0, .1);
      vec3 orange = vec3(1., .5, .1);
      vec3 purple = vec3(.1, 0., .3);
      vec3 white  = vec3(1., 1., 1.);
      x = fract(x) * 4.;
           if (x < 1.) { return mix_cubic(purple, maroon, orange, white , fract(x)); }
      else if (x < 2.) { return mix_cubic(maroon, orange, white , purple, fract(x)); }
      else if (x < 3.) { return mix_cubic(orange, white , purple, maroon, fract(x)); }
      else if (x < 4.) { return mix_cubic(white , purple, maroon, orange, fract(x)); }
      else             { return maroon; }
    }

    vec4 color(float x) {
      float real_colorfulness = colorfulness;
      if (coloring_method == 0 || coloring_method == 1) {
        real_colorfulness /= 5000.;
      } else if (coloring_method == 2) {
        real_colorfulness /= 100.;
      } else {
        real_colorfulness /= 150.;
      }
      x = x * real_colorfulness + color_offset;

      if (colorscheme == 0) {
        return vec4(classic_colorscheme(x), 1);
      } else if (colorscheme == 1) {
        return vec4(experimental_colorscheme(x), 1.);
      } else if (colorscheme == 2) {
        return vec4(rachels_colorscheme(x), 1.);
      }
    }

    void draw_crosshair(vec2 center, vec2 pixel_coord, vec3 color) {
      float distance_to_center = magnitude(center - pixel_coord) * scale_factor;
      if (distance_to_center > .14 && distance_to_center < .15 ||
          distance_to_center > .08 && distance_to_center < .085) {
        fragmentColor = vec4(color, 1.);
        return;
      }
      float angle = atan(pixel_coord.y - center.y,
                         pixel_coord.x - center.x);
      if (distance_to_center > abs(sin(angle * 2.)) && distance_to_center < .17 && distance_to_center > .03) {
        fragmentColor = vec4(color, 1.);
      }
    }

    vec2 iterate(vec2 z, vec2 c, int type) {
      if (type == 0) {
        // Mandelbrot
        return c + vec2(square(z.x) - square(z.y),
                        2. * z.x * z.y);
      } else if (type == 1) {
        // Heart
        return c + vec2(z.x * z.y,
                        abs(z.y) - abs(z.x));
      } else if (type == 2) {
        // Burning ship
        return c + vec2(square(z.x) - square(z.y),
                        -abs(2. * z.x * z.y));
      }
    }

    void main() {
      vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
      vec2 original_z = vertex_position * window / scale_factor + center;
      vec2 last_z = original_z;
      vec2 z = original_z;
      float distance_to_orbit_trap = 1000000.;
      for (int i = 0; i <= max_iterations; i++) {
        if (julify) {
          z = iterate(z, crosshair, fractal_type);
        } else {
          z = iterate(z, original_z, fractal_type);
        }
        if (coloring_method == 0) {
          // Color by how many iterations it takes to diverge
          if (magnitude(z) > divergence_threshold) {
            fragmentColor = color(float(i));
            break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 1) {
          // Same as above, but smooth instead of terraced
          if (magnitude(z) > divergence_threshold) {
            float float_iters = float(i) + log(divergence_threshold / magnitude(last_z)) /
                                           log(magnitude(z) / magnitude(last_z));
            fragmentColor = color(float_iters);
            break;
          } else if (i == max_iterations) {
            fragmentColor = vec4(0., 0., 0., 1.);
          }
        } else if (coloring_method == 2) {
          // Color by the log of the magnitude after iterating a whole bunch
          if (magnitude(z) > divergence_threshold) {
            fragmentColor = vec4(0., 0., 0., 1.);
            break;
          } else {
            fragmentColor = color(log(magnitude(z)));
          }
        } else if (coloring_method == 3) {
          // Color based on how close z gets to a ring around the origin with radius equal to the divergence threshold
          distance_to_orbit_trap = min(distance_to_orbit_trap, abs(magnitude(z) - divergence_threshold));
          fragmentColor = color(-log(distance_to_orbit_trap));
        }
        last_z = z;
      }
      if (!julify) {
        draw_crosshair(crosshair, original_z, vec3(1.) - fragmentColor.xyz / 3.);
      }
    }
  </script>
</body>
</html>
